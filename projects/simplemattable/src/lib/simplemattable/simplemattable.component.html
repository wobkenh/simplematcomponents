<div *ngIf="filter" fxFlex="0 0 auto">
  <mat-form-field style="width: 100%;">
    <input matInput (keyup)="applyFilter($event.target.value)" placeholder="Filter">
  </mat-form-field>
</div>
<div *ngIf="loading && !infiniteScrolling" class="loading-div">
  <div style="display: flex; align-items: center; justify-content: center; flex: 0 1 100vh;">
    <mat-progress-spinner mode="indeterminate" color="primary"></mat-progress-spinner>
  </div>
</div>
<div fxFlex [ngStyle]="getOuterContainerStyle()" (scroll)="onScrollComponent($event)" #scrollContainer id="smtScrollContainer">
  <table mat-table [dataSource]="dataSource" matSort [matSortDisabled]="!sorting" style="width: 100%"
         [ngClass]="getTableClass()">
    <ng-container *ngFor="let tcol of getDisplayedCols(columns); let columnIndex = index">
      <ng-container matColumnDef="{{columnIndex.toString() + '_' + tcol.property.toString()}}">
        <th mat-header-cell *matHeaderCellDef [ngStyle]="getTableCellStyle(tcol)"
            [fxHide.xs]="tcol.hiddenXs || tcol.hiddenSm" [fxHide.sm]="tcol.hiddenSm">
          <div fxLayout="row" style="height: 100%"
               [fxLayoutAlign]="tcol.colFilter ? getHeaderFilterAlign(tcol.align) : getHeaderNoFilterAlign(tcol.align)">
            <div fxLayout="column" *ngIf="!tcol.colFilter">
              <div [ngStyle.gt-xs]="{'padding': sorting ? isCenterAlign(tcol) ? '0 0 0 18px' : '0 0 0 5px' : '0 5px'}">
              <span mat-sort-header [disabled]="!tcol.sortable"
                    [ngClass]="{'no-sort': !(tcol.sortable && sorting), 'with-sort': tcol.sortable && sorting}">
                {{tcol.name}}
              </span>
              </div>
            </div>
            <div fxLayout="column" *ngIf="tcol.colFilter">
              <div [ngStyle.gt-xs]="{'padding': sorting ? isCenterAlign(tcol) ? '0 0 0 18px' : '0 0 0 5px' : '0 5px'}">
              <span mat-sort-header [disabled]="!tcol.sortable"
                    [ngClass]="{'no-sort': !(tcol.sortable && sorting), 'with-sort': tcol.sortable && sorting}">
                {{tcol.name}}
              </span>
              </div>
              <div style="padding: 0 5px">
                <mat-form-field [ngStyle]="{'text-align': getTextAlign(tcol.align)}">
                  <input matInput placeholder="Filter" [formControl]="getColFilterFormControl(tcol)"
                         (keyup)="applyColFilter()" (click)="$event.stopPropagation()">
                </mat-form-field>
              </div>
            </div>
          </div>
        </th>

        <td mat-cell *matCellDef="let element; let rowIndex = index;"
            [fxHide.xs]="tcol.hiddenXs || tcol.hiddenSm" [fxHide.sm]="tcol.hiddenSm"
            (click)="onClick(tcol, element, false)">
          <div
            fxLayout="row" [fxLayoutAlign]="getCellAlign(tcol.align)"
            [ngClass]="getCellCssClass(tcol, element)"
            [ngStyle]="getCellCssStyle(tcol, element)">


            <!--            Explanation for the hierarchy:-->
            <!--            1. Check if it is a button. If yes, display as button only-->
            <!--            2. Check if the cell is currently edited. If yes, display as form field with form control-->
            <!--            3. Check if the cell is directly edited (= constantly editing). If yes, display as form field with ngModel-->
            <!--            4. If previous checks failed, display as text/textarea-->
            <!--            The hierarchie with "ngIf else" is used to avoid duplicate condition checks -->
            <ng-container *ngIf="!tcol.button; else tdButtonCell">
              <!-- FormFields -->
              <!-- You cannot wrap mat-error or input + mat-error into ng-container -->
              <!-- for errors: angular material only looks at direct childs of mat-form-field -->
              <!-- For input + mat-error: ExpressionChangedAfterItHasBeenCheckedError will be thrown if wrapped in
               a ng-container with formControl input binding when the error message changes -->
              <!-- No other chance than to tolerate the duplicate code here. -->
              <ng-container *ngIf="isEditingColumn(tcol, element); else tdNotEditing"
                            [ngSwitch]="tcol.formField.formType">
                <mat-form-field *ngSwitchCase="formFieldType.TEXT" style="width: 100%;padding: 0 5px"
                                (keyup.enter)="saveElement(rowIndex, element)">
                  <input matInput [formControl]="getFormControl(rowIndex, columnIndex, tcol, element)" type="text"
                         [placeholder]="tcol.formField.placeholder"
                         [id]="tcol.formField.focus ? rowIndex + '-smt-focus-input' : ''">
                  <mat-error *ngFor="let error of getCurrentErrors(rowIndex, columnIndex, tcol, element);">
                    {{error.msg}}
                  </mat-error>
                  <mat-hint>{{tcol.formField.hint}}</mat-hint>
                </mat-form-field>
                <mat-form-field *ngSwitchCase="formFieldType.NUMBER" style="width: 100%;padding: 0 5px"
                                (keyup.enter)="saveElement(rowIndex, element)">
                  <input matInput type="number" [formControl]="getFormControl(rowIndex, columnIndex, tcol, element)"
                         [placeholder]="tcol.formField.placeholder"
                         [id]="tcol.formField.focus ? rowIndex + '-smt-focus-input' : ''">
                  <mat-error *ngFor="let error of getCurrentErrors(rowIndex, columnIndex, tcol, element);">
                    {{error.msg}}
                  </mat-error>
                  <mat-hint>{{tcol.formField.hint}}</mat-hint>
                </mat-form-field>
                <mat-checkbox *ngSwitchCase="formFieldType.CHECKBOX" (keyup.enter)="saveElement(rowIndex, element)"
                              [formControl]="getFormControl(rowIndex, columnIndex, tcol, element)"
                              style="padding: 0 5px"
                ></mat-checkbox>
                <mat-form-field *ngSwitchCase="formFieldType.DATE" style="width: 98%;">
                  <!-- For whatever reason, you cant wrap the date picker input in a ng-container -->
                  <input matInput [formControl]="getFormControl(rowIndex, columnIndex, tcol, element)"
                         [id]="tcol.formField.focus ? rowIndex + '-smt-focus-input' : ''"
                         [ngStyle]="{'text-align': getTextAlign(tcol.align)}" [matDatepicker]="picker"
                         [placeholder]="tcol.formField.placeholder" (keyup.enter)="saveElement(rowIndex, element)">
                  <mat-datepicker-toggle matSuffix [for]="picker"></mat-datepicker-toggle>
                  <mat-datepicker #picker></mat-datepicker>
                  <mat-error *ngFor="let error of getCurrentErrors(rowIndex, columnIndex, tcol, element);">
                    {{error.msg}}
                  </mat-error>
                  <mat-hint>{{tcol.formField.hint}}</mat-hint>
                </mat-form-field>
                <mat-form-field *ngSwitchCase="formFieldType.SELECT" style="width: 100%;padding: 0 5px">
                  <mat-select [formControl]="getFormControl(rowIndex, columnIndex, tcol, element)"
                              [placeholder]="tcol.formField.placeholder"
                              [id]="tcol.formField.focus ? rowIndex + '-smt-focus-input' : ''">
                    <mat-option *ngFor="let option of getFormFieldOptions(tcol.formField);" [value]="option.value">
                      {{option.display}}
                    </mat-option>
                  </mat-select>
                  <mat-error *ngFor="let error of getCurrentErrors(rowIndex, columnIndex, tcol, element);">
                    {{error.msg}}
                  </mat-error>
                  <mat-hint>{{tcol.formField.hint}}</mat-hint>
                </mat-form-field>
                <mat-form-field *ngSwitchCase="formFieldType.LARGE_TEXT" style="width: 100%;padding: 0 5px">
                <textarea matInput [formControl]="getFormControl(rowIndex, columnIndex, tcol, element)"
                          style="width: 100%; padding: 2px 0;"
                          [id]="tcol.formField.focus ? rowIndex + '-smt-focus-input' : ''"
                          matTextareaAutosize [matAutosizeMaxRows]="getFormFieldMaxLines(tcol.formField)"
                          [matAutosizeMinRows]="getFormFieldMinLines(tcol.formField)"
                          [placeholder]="tcol.formField.placeholder"></textarea>
                  <mat-error *ngFor="let error of getCurrentErrors(rowIndex, columnIndex, tcol, element);">
                    {{error.msg}}
                  </mat-error>
                  <mat-hint>{{tcol.formField.hint}}</mat-hint>
                </mat-form-field>
              </ng-container>

              <ng-template #tdNotEditing>
                <!-- Direct Edit Form Fields (ngModel instead of form controls) -->
                <ng-container *ngIf="tcol.directEdit && tcol.formField; else tdDefault"
                              [ngSwitch]="tcol.formField.formType">
                  <mat-form-field *ngSwitchCase="formFieldType.TEXT" style="width: 100%;padding: 0 5px">
                    <input matInput type="text" [placeholder]="tcol.formField.placeholder"
                           [(ngModel)]="element[tcol.property]"
                           [id]="tcol.formField.focus ? rowIndex + '-smt-focus-input' : ''">
                    <mat-hint>{{tcol.formField.hint}}</mat-hint>
                  </mat-form-field>
                  <mat-form-field *ngSwitchCase="formFieldType.NUMBER" style="width: 100%;padding: 0 5px">
                    <input matInput type="number" [(ngModel)]="element[tcol.property]"
                           [placeholder]="tcol.formField.placeholder"
                           [id]="tcol.formField.focus ? rowIndex + '-smt-focus-input' : ''">
                    <mat-hint>{{tcol.formField.hint}}</mat-hint>
                  </mat-form-field>
                  <mat-checkbox *ngSwitchCase="formFieldType.CHECKBOX" style="padding: 0 5px"
                                [(ngModel)]="element[tcol.property]"
                  ></mat-checkbox>
                  <mat-form-field *ngSwitchCase="formFieldType.DATE" style="width: 98%;">
                    <!-- For whatever reason, you cant wrap the date picker input in a ng-container -->
                    <input matInput [id]="tcol.formField.focus ? rowIndex + '-smt-focus-input' : ''"
                           [ngStyle]="{'text-align': getTextAlign(tcol.align)}" [matDatepicker]="picker"
                           [placeholder]="tcol.formField.placeholder">
                    <mat-datepicker-toggle matSuffix [for]="picker"></mat-datepicker-toggle>
                    <mat-datepicker #picker></mat-datepicker>
                    <mat-hint>{{tcol.formField.hint}}</mat-hint>
                  </mat-form-field>
                  <mat-form-field *ngSwitchCase="formFieldType.SELECT" style="width: 100%;padding: 0 5px">
                    <mat-select [(ngModel)]="element[tcol.property]" [placeholder]="tcol.formField.placeholder"
                                [id]="tcol.formField.focus ? rowIndex + '-smt-focus-input' : ''">
                      <mat-option *ngFor="let option of getFormFieldOptions(tcol.formField);" [value]="option.value">
                        {{option.display}}
                      </mat-option>
                    </mat-select>
                    <mat-hint>{{tcol.formField.hint}}</mat-hint>
                  </mat-form-field>
                  <mat-form-field *ngSwitchCase="formFieldType.LARGE_TEXT" style="width: 100%;padding: 0 5px">
                <textarea matInput [(ngModel)]="element[tcol.property]"
                          style="width: 100%; padding: 2px 0;"
                          [id]="tcol.formField.focus ? rowIndex + '-smt-focus-input' : ''"
                          matTextareaAutosize [matAutosizeMaxRows]="getFormFieldMaxLines(tcol.formField)"
                          [matAutosizeMinRows]="getFormFieldMinLines(tcol.formField)"
                          [placeholder]="tcol.formField.placeholder"></textarea>
                    <mat-hint>{{tcol.formField.hint}}</mat-hint>
                  </mat-form-field>
                </ng-container>

                <ng-template #tdDefault>
                  <!-- Standardcell: Icon + (Textarea or Span) -->
                  <div *ngIf="(!tcol.directEdit || !tcol.formField) && !isEditingColumn(tcol, element)"
                       fxLayout="row"
                       fxLayoutGap="5px"
                       [fxLayoutAlign]="getCellAlign(tcol.align)" [ngStyle.gt-xs]="{'padding':'0 5px'}"
                       style="width: 100%;">
                    <mat-icon *ngIf="tcol.icon">{{getIconName(tcol, element)}}</mat-icon>
                    <!-- Warning: Do not introduce linebreaks into the textareas content as they will be displayed -->
                    <!-- Be careful when formatting -->
                    <textarea *ngIf="tcol.maxLines && getStringRepresentation(tcol, element)"
                              matInput matTextareaAutosize [matAutosizeMaxRows]="tcol.maxLines"
                              [matAutosizeMinRows]="tcol.minLines" [readonly]="true"
                              [ngStyle]="{'text-align': getTextAlign(tcol.align)}"
                              [fxHide.xs]="tcol.textHiddenXs || tcol.textHiddenSm"
                              [fxHide.sm]="tcol.textHiddenSm"
                              style="width: 100%; padding: 2px 0;">{{getStringRepresentation(tcol, element)}}</textarea>
                    <span style="padding: 2px 0" [fxHide.xs]="tcol.textHiddenXs || tcol.textHiddenSm"
                          [fxHide.sm]="tcol.textHiddenSm"
                          *ngIf="!tcol.maxLines && getStringRepresentation(tcol, element)">
                  {{getStringRepresentation(tcol, element)}}
                </span>
                  </div>
                </ng-template>
              </ng-template>

            </ng-container>


            <ng-template #tdButtonCell>
              <!-- Buttoncells -->
              <button *ngIf="tcol.button === buttonType.BASIC" mat-button [color]="tcol.buttonColor"
                      (click)="onClick(tcol, element, true)" [disabled]="isButtonDisabled(tcol, element)" type="button">
                <mat-icon *ngIf="tcol.icon">{{getIconName(tcol, element)}}</mat-icon>
                <span style="padding: 2px 0" *ngIf="getStringRepresentation(tcol, element)"
                      [fxHide.xs]="tcol.textHiddenXs || tcol.textHiddenSm" [fxHide.sm]="tcol.textHiddenSm">
                {{getStringRepresentation(tcol, element)}}
              </span>
              </button>
              <button *ngIf="tcol.button === buttonType.RAISED" mat-raised-button [color]="tcol.buttonColor"
                      (click)="onClick(tcol, element, true)" [disabled]="isButtonDisabled(tcol, element)" type="button">
                <mat-icon *ngIf="tcol.icon">{{getIconName(tcol, element)}}</mat-icon>
                <span style="padding: 2px 0" *ngIf="getStringRepresentation(tcol, element)"
                      [fxHide.xs]="tcol.textHiddenXs || tcol.textHiddenSm" [fxHide.sm]="tcol.textHiddenSm">
                {{getStringRepresentation(tcol, element)}}
              </span>
              </button>
              <button *ngIf="tcol.button === buttonType.ICON" mat-icon-button [color]="tcol.buttonColor"
                      (click)="onClick(tcol, element, true)" [disabled]="isButtonDisabled(tcol, element)" type="button">
                <mat-icon *ngIf="tcol.icon">{{getIconName(tcol, element)}}</mat-icon>
              </button>
            </ng-template>
          </div>
        </td>
      </ng-container>
    </ng-container>

    <!-- edit/add/delete buttons -->
    <ng-container *ngIf="editable || deletable || addable" matColumnDef="actions">
      <th mat-header-cell *matHeaderCellDef style="width: 104px;">
        <div class="filler-div" style="align-items: center; display: flex; justify-content: flex-end;">
          <button mat-icon-button *ngIf="addable" color="primary" (click)="startAddElement()"
                  [disabled]="!!addedItem">
            <mat-icon>{{addIcon ? addIcon : "add_box"}}</mat-icon>
          </button>
        </div>
      </th>
      <td mat-cell *matCellDef="let element; let rowIndex = index;">
        <div style="display: flex;justify-content: flex-end; align-items: center" class="filler-div">
          <ng-container *ngIf="!isLoading(element)">
            <button *ngIf="editable && !isEditing(element)" mat-icon-button color="primary"
                    (click)="startEditElement(element, rowIndex)">
              <mat-icon>{{editIcon ? editIcon : "edit"}}</mat-icon>
            </button>
            <button *ngIf="deletable && element !== addedItem" mat-icon-button color="primary"
                    (click)="deleteElement(element)">
              <mat-icon>{{deleteIcon ? deleteIcon : "delete"}}</mat-icon>
            </button>
            <ng-container *ngIf="(editable || addable) && isEditing(element)">
              <button mat-icon-button color="primary" (click)="saveElement(rowIndex, element)"
                      [disabled]="!isFormValid(rowIndex)">
                <mat-icon>{{saveIcon ? saveIcon : "save"}}</mat-icon>
              </button>
              <button mat-icon-button color="primary" (click)="cancelEditElement(element)">
                <mat-icon>{{cancelIcon ? cancelIcon : "cancel"}}</mat-icon>
              </button>
            </ng-container>
          </ng-container>
          <mat-spinner *ngIf="isLoading(element)" [diameter]="40"></mat-spinner>
        </div>
      </td>
    </ng-container>

    <tr mat-header-row *matHeaderRowDef="displayedColumns; sticky: sticky" [ngStyle]="getTableHeaderStyle()"></tr>
    <tr mat-row *matRowDef="let row; columns: displayedColumns;"></tr>
  </table>

  <div *ngIf="loading && infiniteScrolling" style="display: flex; justify-content: center; padding-top: 15px; padding-bottom: 10px; overflow: hidden;">
      <mat-progress-spinner mode="indeterminate" color="primary"></mat-progress-spinner>
  </div>

</div>

<ng-container *ngIf="paginator">
  <mat-paginator *ngIf="backendPagination; else frontendPaginatorTemplate" style="margin-top: 10px" fxFlex="0 0 auto"
                 #backendPaginator
                 [length]="paginatorLength"
                 [pageSize]="paginatorPageSize"
                 [pageSizeOptions]="paginatorPageSizeOptions"
                 [showFirstLastButtons]="true"
                 (page)="onPageEvent($event)"
  >
  </mat-paginator>
  <ng-template #frontendPaginatorTemplate>
    <mat-paginator style="margin-top: 10px" fxFlex="0 0 auto"
                   #frontendPaginator
                   [pageSize]="paginatorPageSize"
                   [pageSizeOptions]="paginatorPageSizeOptions"
                   [showFirstLastButtons]="true">
    </mat-paginator>
  </ng-template>
</ng-container>
